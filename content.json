{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"winter","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"八大基础排序算法的笔记","slug":"基础排序算法的笔记","date":"2019-08-16T15:42:00.000Z","updated":"2019-08-19T16:06:05.966Z","comments":true,"path":"2019/08/16/基础排序算法的笔记/","link":"","permalink":"http://yoursite.com/2019/08/16/基础排序算法的笔记/","excerpt":"1、稳定性 归并排序、冒泡排序、插入排序。基数排序是稳定的 选择排序、快速排序、希尔排序、堆排序是不稳定的 2.时间复杂度 最基础的四个算法：冒泡、选择、插入、快排中，快排的时间复杂度最小O(n*log2n)，其他都是O（n2） 排序法 平均时间 最差情形 稳定度 额外空间 备注 冒泡 O(n2) O(n2) 稳定 O(1) n小时较好 选择 O(n2) O(n2) 不稳定 O(1) n小时较好 插入 O(n2) O(n2) 稳定 O(1) 大部分已排序时较好 基数 O(logRB) O(logRB) 稳定 O(n) B是真数(0-9)，R是基数(个十百) Shell O(nlogn) O(ns) 1&lt;s&lt;2 不稳定 O(1) s是所选分组 快速 O(nlogn) O(n2) 不稳定 O(nlogn) n大时较好 归并 O(nlogn) O(nlogn) 稳定 O(1) n大时较好 堆 O(nlogn) O(nlogn) 不稳定 O(1) n大时较好","text":"1、稳定性 归并排序、冒泡排序、插入排序。基数排序是稳定的 选择排序、快速排序、希尔排序、堆排序是不稳定的 2.时间复杂度 最基础的四个算法：冒泡、选择、插入、快排中，快排的时间复杂度最小O(n*log2n)，其他都是O（n2） 排序法 平均时间 最差情形 稳定度 额外空间 备注 冒泡 O(n2) O(n2) 稳定 O(1) n小时较好 选择 O(n2) O(n2) 不稳定 O(1) n小时较好 插入 O(n2) O(n2) 稳定 O(1) 大部分已排序时较好 基数 O(logRB) O(logRB) 稳定 O(n) B是真数(0-9)，R是基数(个十百) Shell O(nlogn) O(ns) 1&lt;s&lt;2 不稳定 O(1) s是所选分组 快速 O(nlogn) O(n2) 不稳定 O(nlogn) n大时较好 归并 O(nlogn) O(nlogn) 稳定 O(1) n大时较好 堆 O(nlogn) O(nlogn) 不稳定 O(1) n大时较好 #1. 冒泡排序思想：相邻元素间的交换，若相等则不换，是稳定的排序第一趟 1 2 5 6 7 3 4 0 8 9 //确定最大的一个 9第二趟 1 2 5 6 3 4 0 7 8 9//确定 8第三趟 1 2 5 3 4 0 6 7 8 9//确定 7。。。第九趟 0 1 2 3 4 5 6 7 8 9//确定 1 和最小的 0元素长度为n 则需n-1趟 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;//数组长度#define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) /** 冒泡排序* * 参数说明：* i --- 趟数* j --- 比较次数*/int main()&#123; int a[10] = &#123;1,5,2,6,8,7,3,4,0,9&#125;; int i; for(i = 0; i &lt; LENGTH(a) - 1; i++ )&#123;//比几趟 n-1 for(j = 0; j &lt; LENGTH(a) - 1 -i;j++) &#123;//一趟比几次 每趟会少比一次 if( a[j] &gt;= a[j + 1] )&#123; a[j] = a[j + 1] + a[j]; a[j + 1] = a[j] - a[j + 1]; a[j] = a[j] - a[j + 1]; &#125; &#125; &#125; for(i = 0; i &lt; 10; i++)&#123; printf(&quot;%d&quot;,a[i]); &#125;&#125; 优化冒泡思想：因为每次只能确定一个，但交换时可能出现已经已经排好的情况，也就是没进行交换，设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可第一趟 1 2 5 6 7 3 4 0 8 9 //pos 下标为7 确定了 8 9第二趟 1 2 5 6 3 4 0 7 8 9//pos 下标为6 确定了 7第三趟 1 2 5 3 4 0 6 7 8 9//pos 下标为5 确定了 6第四趟 1 2 3 4 0 5 6 7 8 9//pos 下标为4 确定了 5第五趟 1 2 3 4 0 5 6 7 8 9//pos 下标为3 确定了 4第六趟 1 2 3 4 0 5 6 7 8 9//pos 下标为2 确定了 3第七趟 1 2 3 4 0 5 6 7 8 9//pos 下标为1 确定了 2第八趟 1 2 3 4 0 5 6 7 8 9//pos 下标为0 确定了 1优化了一趟（数据没选好QAQ） 123456789101112131415161718192021222324252627282930//数组长度#define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) /** 冒泡排序优化* * 参数说明：* i --- 趟数* j --- 比较次数* pos --- 记录交换位置的下标*/int main()&#123; int a[10] = &#123;1,5,2,6,8,7,3,4,0,9&#125;; int j; int i= 10 -1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; int pos = 0; //每趟开始时,无记录交换 for ( j= 0; j&lt; i; j++) if (a[j]&gt; a[j+1]) &#123; pos= j; //记录交换的位置 int tmp = a[j]; a[j]=a[j+1]; a[j+1]=tmp; &#125; i = pos; //为下一趟排序作准备 &#125; for(i = 0; i &lt; 10; i++)&#123; printf(&quot;%d&quot;,r[i]); &#125;&#125; #2.选择排序思想：从无序序列中找出最小元素和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。第一次选择 {0}（5 2 6 8 7 3 4 1 9）第二次选择 {0 1}（2 6 8 7 3 4 5 9）第三次选择 {0 1 2}（6 8 7 3 4 5 9）第四次选择 {0 1 2 3}（8 7 6 4 5 9）第五次选择 {0 1 2 3 4}（7 6 8 5 9）第六次选择 {0 1 2 3 4 5}（8 6 7 9）第七次选择 {0 1 2 3 4 5 6}（8 7 9）第八次选择 {0 1 2 3 4 5 6 7}（8 9）第九次选择 {0 1 2 3 4 5 6 7 8 9 } 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;//数组长度#define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) /** 选择排序* * 参数说明：* i --- 趟数* j --- 比较次数* index --- 记录无序列表下标最小的位置* tmp --- 临时存储变量*/int main()&#123; int a[10] = &#123;1,5,2,6,8,7,3,4,0,9&#125;; int i;//几次选择 int j;//无序序列的首部 int index;//记录比无序序列首部还小的位置的下标 int tmp; for(i = 0; i &lt; LENGTH(a) - 1; i ++)&#123; index = i; for(j = i + 1; j &lt; LENGTH(a); j ++)&#123; if(a[j] &lt; a[index])&#123; index = j; &#125; &#125; tmp = a[i]; a[i] = a[index]; a[index] = tmp; &#125; for(i = 0; i &lt; 10; i++)&#123; printf(&quot;%d&quot;,a[i]); &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"test","slug":"test","date":"2019-08-16T13:19:00.000Z","updated":"2019-08-16T14:56:56.190Z","comments":true,"path":"2019/08/16/test/","link":"","permalink":"http://yoursite.com/2019/08/16/test/","excerpt":"","text":"###test23","categories":[],"tags":[]},{"title":"Git的学习","slug":"GitStudy","date":"2019-08-16T05:55:00.000Z","updated":"2019-08-16T15:03:06.223Z","comments":true,"path":"2019/08/16/GitStudy/","link":"","permalink":"http://yoursite.com/2019/08/16/GitStudy/","excerpt":"","text":"##Git简介 Git是基于c语言的分布式版本控制系统 集中式 vs 分布式 版本库集中存放在中央服务器 每个人的电脑都是版本库 必须联网，不灵活 方便大家修改 初始化一个Git仓库，使用git init命令 添加文件到Git仓库，分两步 使用git add &lt;file&gt;，可以反复多次使用，添加多个文件 使用命令git commit -m &quot;message&quot;,完成##时光机穿梭 git status命令查看工作区的状态 如果git status告诉你有文件被修改过，用git diff可以查看修改的内容","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-16T05:24:13.100Z","updated":"2019-08-16T05:38:39.549Z","comments":true,"path":"2019/08/16/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ###你好###","categories":[],"tags":[]}]}